// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package MurmurRPC

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// V1Client is the client API for V1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type V1Client interface {
	// Deepfake study
	InjectAudio(ctx context.Context, in *AudioInjection, opts ...grpc.CallOption) (*Void, error)
	// GetUptime returns murmur's uptime.
	GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error)
	// Events returns a stream of murmur events.
	Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (V1_EventsClient, error)
	// ServerCreate creates a new virtual server. The returned server object
	// contains the newly created server's ID.
	ServerCreate(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error)
	// ServerQuery returns a list of servers that match the given query.
	ServerQuery(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error)
	// ServerGet returns information about the given server.
	ServerGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error)
	// ServerStart starts the given stopped server.
	ServerStart(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerStop stops the given virtual server.
	ServerStop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerRemove removes the given virtual server and its configuration.
	ServerRemove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerEvents returns a stream of events that happen on the given server.
	ServerEvents(ctx context.Context, in *Server, opts ...grpc.CallOption) (V1_ServerEventsClient, error)
	// ContextActionAdd adds a context action to the given user's client. The
	// following ContextAction fields must be set:
	//   context, action, text, and user.
	//
	// Added context actions are valid until:
	//  - The context action is removed with ContextActionRemove, or
	//  - The user disconnects from the server, or
	//  - The server stops.
	ContextActionAdd(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// ContextActionRemove removes a context action from the given user's client.
	// The following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	ContextActionRemove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// ContextActionEvents returns a stream of context action events that are
	// triggered by users.
	ContextActionEvents(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (V1_ContextActionEventsClient, error)
	// TextMessageSend sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	TextMessageSend(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error)
	// TextMessageFilter filters text messages for a given server.
	//
	// When a filter stream is active, text messages sent from users to the
	// server are sent over the stream. The RPC client then sends a message back
	// on the same stream, containing an action: whether the message should be
	// accepted, rejected, or dropped.
	//
	// To activate the filter stream, an initial TextMessage.Filter message must
	// be sent that contains the server on which the filter will be active.
	TextMessageFilter(ctx context.Context, opts ...grpc.CallOption) (V1_TextMessageFilterClient, error)
	// LogQuery returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	LogQuery(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error)
	// ConfigGet returns the explicitly set configuration for the given server.
	ConfigGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error)
	// ConfigGetField returns the configuration value for the given key.
	ConfigGetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error)
	// ConfigSetField sets the configuration value to the given value.
	ConfigSetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error)
	// ConfigGetDefault returns the default server configuration.
	ConfigGetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error)
	// ChannelQuery returns a list of channels that match the given query.
	ChannelQuery(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error)
	// ChannelGet returns the channel with the given ID.
	ChannelGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// ChannelAdd adds the channel to the given server. The parent and name of
	// the channel must be set.
	ChannelAdd(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// ChannelRemove removes the given channel from the server.
	ChannelRemove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error)
	// ChannelUpdate updates the given channel's attributes. Only the fields that
	// are set will be updated.
	ChannelUpdate(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// UserQuery returns a list of connected users who match the given query.
	UserQuery(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error)
	// UserGet returns information on the connected user, given by the user's
	// session or name.
	UserGet(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// UserUpdate changes the given user's state. Only the following fields can
	// be changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	UserUpdate(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// UserKick kicks the user from the server.
	UserKick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error)
	// TreeQuery returns a representation of the given server's channel/user
	// tree.
	TreeQuery(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error)
	// BansGet returns a list of bans for the given server.
	BansGet(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error)
	// BansSet replaces the server's ban list with the given list.
	BansSet(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error)
	// ACLGet returns the ACL for the given channel.
	ACLGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error)
	// ACLSet overrides the ACL of the given channel to what is provided.
	ACLSet(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error)
	// ACLGetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	ACLGetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error)
	// ACLAddTemporaryGroup adds a user to a temporary group.
	ACLAddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// ACLRemoveTemporaryGroup removes a user from a temporary group.
	ACLRemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// AuthenticatorStream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	AuthenticatorStream(ctx context.Context, opts ...grpc.CallOption) (V1_AuthenticatorStreamClient, error)
	// DatabaseUserQuery returns a list of registered users who match given
	// query.
	DatabaseUserQuery(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error)
	// DatabaseUserGet returns the database user with the given ID.
	DatabaseUserGet(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// DatabaseUserUpdate updates the given database user.
	DatabaseUserUpdate(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// DatabaseUserRegister registers a user with the given information on the
	// server. The returned DatabaseUser will contain the newly registered user's
	// ID.
	DatabaseUserRegister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// DatabaseUserDeregister deregisters the given user.
	DatabaseUserDeregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// DatabaseUserVerify verifies the that the given user-password pair is
	// correct.
	DatabaseUserVerify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error)
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	RedirectWhisperGroupAdd(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RedirectWhisperGroupRemove(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
}

type v1Client struct {
	cc grpc.ClientConnInterface
}

func NewV1Client(cc grpc.ClientConnInterface) V1Client {
	return &v1Client{cc}
}

func (c *v1Client) InjectAudio(ctx context.Context, in *AudioInjection, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/InjectAudio", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error) {
	out := new(Uptime)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/GetUptime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (V1_EventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &V1_ServiceDesc.Streams[0], "/MurmurRPC.V1/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1EventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_EventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type v1EventsClient struct {
	grpc.ClientStream
}

func (x *v1EventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) ServerCreate(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ServerCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerQuery(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error) {
	out := new(Server_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ServerQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ServerGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerStart(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ServerStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerStop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ServerStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerRemove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ServerRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerEvents(ctx context.Context, in *Server, opts ...grpc.CallOption) (V1_ServerEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &V1_ServiceDesc.Streams[1], "/MurmurRPC.V1/ServerEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1ServerEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_ServerEventsClient interface {
	Recv() (*Server_Event, error)
	grpc.ClientStream
}

type v1ServerEventsClient struct {
	grpc.ClientStream
}

func (x *v1ServerEventsClient) Recv() (*Server_Event, error) {
	m := new(Server_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) ContextActionAdd(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ContextActionAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ContextActionRemove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ContextActionRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ContextActionEvents(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (V1_ContextActionEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &V1_ServiceDesc.Streams[2], "/MurmurRPC.V1/ContextActionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1ContextActionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_ContextActionEventsClient interface {
	Recv() (*ContextAction, error)
	grpc.ClientStream
}

type v1ContextActionEventsClient struct {
	grpc.ClientStream
}

func (x *v1ContextActionEventsClient) Recv() (*ContextAction, error) {
	m := new(ContextAction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) TextMessageSend(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/TextMessageSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) TextMessageFilter(ctx context.Context, opts ...grpc.CallOption) (V1_TextMessageFilterClient, error) {
	stream, err := c.cc.NewStream(ctx, &V1_ServiceDesc.Streams[3], "/MurmurRPC.V1/TextMessageFilter", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1TextMessageFilterClient{stream}
	return x, nil
}

type V1_TextMessageFilterClient interface {
	Send(*TextMessage_Filter) error
	Recv() (*TextMessage_Filter, error)
	grpc.ClientStream
}

type v1TextMessageFilterClient struct {
	grpc.ClientStream
}

func (x *v1TextMessageFilterClient) Send(m *TextMessage_Filter) error {
	return x.ClientStream.SendMsg(m)
}

func (x *v1TextMessageFilterClient) Recv() (*TextMessage_Filter, error) {
	m := new(TextMessage_Filter)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) LogQuery(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error) {
	out := new(Log_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/LogQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ConfigGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error) {
	out := new(Config_Field)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ConfigGetField", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigSetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ConfigSetField", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ConfigGetDefault", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelQuery(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error) {
	out := new(Channel_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ChannelQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ChannelGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelAdd(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ChannelAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelRemove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ChannelRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelUpdate(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ChannelUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserQuery(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error) {
	out := new(User_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/UserQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserGet(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/UserGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserUpdate(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/UserUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserKick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/UserKick", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) TreeQuery(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/TreeQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) BansGet(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error) {
	out := new(Ban_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/BansGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) BansSet(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/BansSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error) {
	out := new(ACL_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ACLGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLSet(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ACLSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLGetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error) {
	out := new(ACL)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ACLGetEffectivePermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLAddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ACLAddTemporaryGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLRemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/ACLRemoveTemporaryGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) AuthenticatorStream(ctx context.Context, opts ...grpc.CallOption) (V1_AuthenticatorStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &V1_ServiceDesc.Streams[4], "/MurmurRPC.V1/AuthenticatorStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1AuthenticatorStreamClient{stream}
	return x, nil
}

type V1_AuthenticatorStreamClient interface {
	Send(*Authenticator_Response) error
	Recv() (*Authenticator_Request, error)
	grpc.ClientStream
}

type v1AuthenticatorStreamClient struct {
	grpc.ClientStream
}

func (x *v1AuthenticatorStreamClient) Send(m *Authenticator_Response) error {
	return x.ClientStream.SendMsg(m)
}

func (x *v1AuthenticatorStreamClient) Recv() (*Authenticator_Request, error) {
	m := new(Authenticator_Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) DatabaseUserQuery(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error) {
	out := new(DatabaseUser_List)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserGet(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserUpdate(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserRegister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserRegister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserDeregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserDeregister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserVerify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) RedirectWhisperGroupAdd(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/RedirectWhisperGroupAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) RedirectWhisperGroupRemove(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/MurmurRPC.V1/RedirectWhisperGroupRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// V1Server is the server API for V1 service.
// All implementations must embed UnimplementedV1Server
// for forward compatibility
type V1Server interface {
	// Deepfake study
	InjectAudio(context.Context, *AudioInjection) (*Void, error)
	// GetUptime returns murmur's uptime.
	GetUptime(context.Context, *Void) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(context.Context, *Void) (*Version, error)
	// Events returns a stream of murmur events.
	Events(*Void, V1_EventsServer) error
	// ServerCreate creates a new virtual server. The returned server object
	// contains the newly created server's ID.
	ServerCreate(context.Context, *Void) (*Server, error)
	// ServerQuery returns a list of servers that match the given query.
	ServerQuery(context.Context, *Server_Query) (*Server_List, error)
	// ServerGet returns information about the given server.
	ServerGet(context.Context, *Server) (*Server, error)
	// ServerStart starts the given stopped server.
	ServerStart(context.Context, *Server) (*Void, error)
	// ServerStop stops the given virtual server.
	ServerStop(context.Context, *Server) (*Void, error)
	// ServerRemove removes the given virtual server and its configuration.
	ServerRemove(context.Context, *Server) (*Void, error)
	// ServerEvents returns a stream of events that happen on the given server.
	ServerEvents(*Server, V1_ServerEventsServer) error
	// ContextActionAdd adds a context action to the given user's client. The
	// following ContextAction fields must be set:
	//   context, action, text, and user.
	//
	// Added context actions are valid until:
	//  - The context action is removed with ContextActionRemove, or
	//  - The user disconnects from the server, or
	//  - The server stops.
	ContextActionAdd(context.Context, *ContextAction) (*Void, error)
	// ContextActionRemove removes a context action from the given user's client.
	// The following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	ContextActionRemove(context.Context, *ContextAction) (*Void, error)
	// ContextActionEvents returns a stream of context action events that are
	// triggered by users.
	ContextActionEvents(*ContextAction, V1_ContextActionEventsServer) error
	// TextMessageSend sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	TextMessageSend(context.Context, *TextMessage) (*Void, error)
	// TextMessageFilter filters text messages for a given server.
	//
	// When a filter stream is active, text messages sent from users to the
	// server are sent over the stream. The RPC client then sends a message back
	// on the same stream, containing an action: whether the message should be
	// accepted, rejected, or dropped.
	//
	// To activate the filter stream, an initial TextMessage.Filter message must
	// be sent that contains the server on which the filter will be active.
	TextMessageFilter(V1_TextMessageFilterServer) error
	// LogQuery returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	LogQuery(context.Context, *Log_Query) (*Log_List, error)
	// ConfigGet returns the explicitly set configuration for the given server.
	ConfigGet(context.Context, *Server) (*Config, error)
	// ConfigGetField returns the configuration value for the given key.
	ConfigGetField(context.Context, *Config_Field) (*Config_Field, error)
	// ConfigSetField sets the configuration value to the given value.
	ConfigSetField(context.Context, *Config_Field) (*Void, error)
	// ConfigGetDefault returns the default server configuration.
	ConfigGetDefault(context.Context, *Void) (*Config, error)
	// ChannelQuery returns a list of channels that match the given query.
	ChannelQuery(context.Context, *Channel_Query) (*Channel_List, error)
	// ChannelGet returns the channel with the given ID.
	ChannelGet(context.Context, *Channel) (*Channel, error)
	// ChannelAdd adds the channel to the given server. The parent and name of
	// the channel must be set.
	ChannelAdd(context.Context, *Channel) (*Channel, error)
	// ChannelRemove removes the given channel from the server.
	ChannelRemove(context.Context, *Channel) (*Void, error)
	// ChannelUpdate updates the given channel's attributes. Only the fields that
	// are set will be updated.
	ChannelUpdate(context.Context, *Channel) (*Channel, error)
	// UserQuery returns a list of connected users who match the given query.
	UserQuery(context.Context, *User_Query) (*User_List, error)
	// UserGet returns information on the connected user, given by the user's
	// session or name.
	UserGet(context.Context, *User) (*User, error)
	// UserUpdate changes the given user's state. Only the following fields can
	// be changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	UserUpdate(context.Context, *User) (*User, error)
	// UserKick kicks the user from the server.
	UserKick(context.Context, *User_Kick) (*Void, error)
	// TreeQuery returns a representation of the given server's channel/user
	// tree.
	TreeQuery(context.Context, *Tree_Query) (*Tree, error)
	// BansGet returns a list of bans for the given server.
	BansGet(context.Context, *Ban_Query) (*Ban_List, error)
	// BansSet replaces the server's ban list with the given list.
	BansSet(context.Context, *Ban_List) (*Void, error)
	// ACLGet returns the ACL for the given channel.
	ACLGet(context.Context, *Channel) (*ACL_List, error)
	// ACLSet overrides the ACL of the given channel to what is provided.
	ACLSet(context.Context, *ACL_List) (*Void, error)
	// ACLGetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	ACLGetEffectivePermissions(context.Context, *ACL_Query) (*ACL, error)
	// ACLAddTemporaryGroup adds a user to a temporary group.
	ACLAddTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// ACLRemoveTemporaryGroup removes a user from a temporary group.
	ACLRemoveTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// AuthenticatorStream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	AuthenticatorStream(V1_AuthenticatorStreamServer) error
	// DatabaseUserQuery returns a list of registered users who match given
	// query.
	DatabaseUserQuery(context.Context, *DatabaseUser_Query) (*DatabaseUser_List, error)
	// DatabaseUserGet returns the database user with the given ID.
	DatabaseUserGet(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// DatabaseUserUpdate updates the given database user.
	DatabaseUserUpdate(context.Context, *DatabaseUser) (*Void, error)
	// DatabaseUserRegister registers a user with the given information on the
	// server. The returned DatabaseUser will contain the newly registered user's
	// ID.
	DatabaseUserRegister(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// DatabaseUserDeregister deregisters the given user.
	DatabaseUserDeregister(context.Context, *DatabaseUser) (*Void, error)
	// DatabaseUserVerify verifies the that the given user-password pair is
	// correct.
	DatabaseUserVerify(context.Context, *DatabaseUser_Verify) (*DatabaseUser, error)
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	RedirectWhisperGroupAdd(context.Context, *RedirectWhisperGroup) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RedirectWhisperGroupRemove(context.Context, *RedirectWhisperGroup) (*Void, error)
	mustEmbedUnimplementedV1Server()
}

// UnimplementedV1Server must be embedded to have forward compatible implementations.
type UnimplementedV1Server struct {
}

func (UnimplementedV1Server) InjectAudio(context.Context, *AudioInjection) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InjectAudio not implemented")
}
func (UnimplementedV1Server) GetUptime(context.Context, *Void) (*Uptime, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUptime not implemented")
}
func (UnimplementedV1Server) GetVersion(context.Context, *Void) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedV1Server) Events(*Void, V1_EventsServer) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (UnimplementedV1Server) ServerCreate(context.Context, *Void) (*Server, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerCreate not implemented")
}
func (UnimplementedV1Server) ServerQuery(context.Context, *Server_Query) (*Server_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerQuery not implemented")
}
func (UnimplementedV1Server) ServerGet(context.Context, *Server) (*Server, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerGet not implemented")
}
func (UnimplementedV1Server) ServerStart(context.Context, *Server) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerStart not implemented")
}
func (UnimplementedV1Server) ServerStop(context.Context, *Server) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerStop not implemented")
}
func (UnimplementedV1Server) ServerRemove(context.Context, *Server) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerRemove not implemented")
}
func (UnimplementedV1Server) ServerEvents(*Server, V1_ServerEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerEvents not implemented")
}
func (UnimplementedV1Server) ContextActionAdd(context.Context, *ContextAction) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContextActionAdd not implemented")
}
func (UnimplementedV1Server) ContextActionRemove(context.Context, *ContextAction) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContextActionRemove not implemented")
}
func (UnimplementedV1Server) ContextActionEvents(*ContextAction, V1_ContextActionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ContextActionEvents not implemented")
}
func (UnimplementedV1Server) TextMessageSend(context.Context, *TextMessage) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TextMessageSend not implemented")
}
func (UnimplementedV1Server) TextMessageFilter(V1_TextMessageFilterServer) error {
	return status.Errorf(codes.Unimplemented, "method TextMessageFilter not implemented")
}
func (UnimplementedV1Server) LogQuery(context.Context, *Log_Query) (*Log_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogQuery not implemented")
}
func (UnimplementedV1Server) ConfigGet(context.Context, *Server) (*Config, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGet not implemented")
}
func (UnimplementedV1Server) ConfigGetField(context.Context, *Config_Field) (*Config_Field, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetField not implemented")
}
func (UnimplementedV1Server) ConfigSetField(context.Context, *Config_Field) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigSetField not implemented")
}
func (UnimplementedV1Server) ConfigGetDefault(context.Context, *Void) (*Config, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetDefault not implemented")
}
func (UnimplementedV1Server) ChannelQuery(context.Context, *Channel_Query) (*Channel_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelQuery not implemented")
}
func (UnimplementedV1Server) ChannelGet(context.Context, *Channel) (*Channel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelGet not implemented")
}
func (UnimplementedV1Server) ChannelAdd(context.Context, *Channel) (*Channel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelAdd not implemented")
}
func (UnimplementedV1Server) ChannelRemove(context.Context, *Channel) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelRemove not implemented")
}
func (UnimplementedV1Server) ChannelUpdate(context.Context, *Channel) (*Channel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUpdate not implemented")
}
func (UnimplementedV1Server) UserQuery(context.Context, *User_Query) (*User_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserQuery not implemented")
}
func (UnimplementedV1Server) UserGet(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGet not implemented")
}
func (UnimplementedV1Server) UserUpdate(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdate not implemented")
}
func (UnimplementedV1Server) UserKick(context.Context, *User_Kick) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserKick not implemented")
}
func (UnimplementedV1Server) TreeQuery(context.Context, *Tree_Query) (*Tree, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TreeQuery not implemented")
}
func (UnimplementedV1Server) BansGet(context.Context, *Ban_Query) (*Ban_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BansGet not implemented")
}
func (UnimplementedV1Server) BansSet(context.Context, *Ban_List) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BansSet not implemented")
}
func (UnimplementedV1Server) ACLGet(context.Context, *Channel) (*ACL_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ACLGet not implemented")
}
func (UnimplementedV1Server) ACLSet(context.Context, *ACL_List) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ACLSet not implemented")
}
func (UnimplementedV1Server) ACLGetEffectivePermissions(context.Context, *ACL_Query) (*ACL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ACLGetEffectivePermissions not implemented")
}
func (UnimplementedV1Server) ACLAddTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ACLAddTemporaryGroup not implemented")
}
func (UnimplementedV1Server) ACLRemoveTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ACLRemoveTemporaryGroup not implemented")
}
func (UnimplementedV1Server) AuthenticatorStream(V1_AuthenticatorStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method AuthenticatorStream not implemented")
}
func (UnimplementedV1Server) DatabaseUserQuery(context.Context, *DatabaseUser_Query) (*DatabaseUser_List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseUserQuery not implemented")
}
func (UnimplementedV1Server) DatabaseUserGet(context.Context, *DatabaseUser) (*DatabaseUser, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseUserGet not implemented")
}
func (UnimplementedV1Server) DatabaseUserUpdate(context.Context, *DatabaseUser) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseUserUpdate not implemented")
}
func (UnimplementedV1Server) DatabaseUserRegister(context.Context, *DatabaseUser) (*DatabaseUser, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseUserRegister not implemented")
}
func (UnimplementedV1Server) DatabaseUserDeregister(context.Context, *DatabaseUser) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseUserDeregister not implemented")
}
func (UnimplementedV1Server) DatabaseUserVerify(context.Context, *DatabaseUser_Verify) (*DatabaseUser, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseUserVerify not implemented")
}
func (UnimplementedV1Server) RedirectWhisperGroupAdd(context.Context, *RedirectWhisperGroup) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectWhisperGroupAdd not implemented")
}
func (UnimplementedV1Server) RedirectWhisperGroupRemove(context.Context, *RedirectWhisperGroup) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectWhisperGroupRemove not implemented")
}
func (UnimplementedV1Server) mustEmbedUnimplementedV1Server() {}

// UnsafeV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to V1Server will
// result in compilation errors.
type UnsafeV1Server interface {
	mustEmbedUnimplementedV1Server()
}

func RegisterV1Server(s grpc.ServiceRegistrar, srv V1Server) {
	s.RegisterService(&V1_ServiceDesc, srv)
}

func _V1_InjectAudio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudioInjection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).InjectAudio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/InjectAudio",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).InjectAudio(ctx, req.(*AudioInjection))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_GetUptime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).GetUptime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/GetUptime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).GetUptime(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).GetVersion(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Void)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).Events(m, &v1EventsServer{stream})
}

type V1_EventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type v1EventsServer struct {
	grpc.ServerStream
}

func (x *v1EventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_ServerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerCreate(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerQuery(ctx, req.(*Server_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerGet(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerStart(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerStop(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerRemove(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Server)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).ServerEvents(m, &v1ServerEventsServer{stream})
}

type V1_ServerEventsServer interface {
	Send(*Server_Event) error
	grpc.ServerStream
}

type v1ServerEventsServer struct {
	grpc.ServerStream
}

func (x *v1ServerEventsServer) Send(m *Server_Event) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_ContextActionAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextAction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ContextActionAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ContextActionAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ContextActionAdd(ctx, req.(*ContextAction))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ContextActionRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextAction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ContextActionRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ContextActionRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ContextActionRemove(ctx, req.(*ContextAction))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ContextActionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContextAction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).ContextActionEvents(m, &v1ContextActionEventsServer{stream})
}

type V1_ContextActionEventsServer interface {
	Send(*ContextAction) error
	grpc.ServerStream
}

type v1ContextActionEventsServer struct {
	grpc.ServerStream
}

func (x *v1ContextActionEventsServer) Send(m *ContextAction) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_TextMessageSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).TextMessageSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/TextMessageSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).TextMessageSend(ctx, req.(*TextMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_TextMessageFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(V1Server).TextMessageFilter(&v1TextMessageFilterServer{stream})
}

type V1_TextMessageFilterServer interface {
	Send(*TextMessage_Filter) error
	Recv() (*TextMessage_Filter, error)
	grpc.ServerStream
}

type v1TextMessageFilterServer struct {
	grpc.ServerStream
}

func (x *v1TextMessageFilterServer) Send(m *TextMessage_Filter) error {
	return x.ServerStream.SendMsg(m)
}

func (x *v1TextMessageFilterServer) Recv() (*TextMessage_Filter, error) {
	m := new(TextMessage_Filter)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _V1_LogQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Log_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).LogQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/LogQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).LogQuery(ctx, req.(*Log_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigGet(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigGetField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigGetField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigGetField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigGetField(ctx, req.(*Config_Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigSetField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigSetField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigSetField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigSetField(ctx, req.(*Config_Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigGetDefault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigGetDefault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigGetDefault",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigGetDefault(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelQuery(ctx, req.(*Channel_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelGet(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelAdd(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelRemove(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelUpdate(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserQuery(ctx, req.(*User_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserGet(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserUpdate(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserKick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User_Kick)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserKick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserKick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserKick(ctx, req.(*User_Kick))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_TreeQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tree_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).TreeQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/TreeQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).TreeQuery(ctx, req.(*Tree_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_BansGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ban_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).BansGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/BansGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).BansGet(ctx, req.(*Ban_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_BansSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ban_List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).BansSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/BansSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).BansSet(ctx, req.(*Ban_List))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLGet(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLSet(ctx, req.(*ACL_List))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLGetEffectivePermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLGetEffectivePermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLGetEffectivePermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLGetEffectivePermissions(ctx, req.(*ACL_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLAddTemporaryGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLAddTemporaryGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLAddTemporaryGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLAddTemporaryGroup(ctx, req.(*ACL_TemporaryGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLRemoveTemporaryGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLRemoveTemporaryGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLRemoveTemporaryGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLRemoveTemporaryGroup(ctx, req.(*ACL_TemporaryGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_AuthenticatorStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(V1Server).AuthenticatorStream(&v1AuthenticatorStreamServer{stream})
}

type V1_AuthenticatorStreamServer interface {
	Send(*Authenticator_Request) error
	Recv() (*Authenticator_Response, error)
	grpc.ServerStream
}

type v1AuthenticatorStreamServer struct {
	grpc.ServerStream
}

func (x *v1AuthenticatorStreamServer) Send(m *Authenticator_Request) error {
	return x.ServerStream.SendMsg(m)
}

func (x *v1AuthenticatorStreamServer) Recv() (*Authenticator_Response, error) {
	m := new(Authenticator_Response)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _V1_DatabaseUserQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserQuery(ctx, req.(*DatabaseUser_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserGet(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserUpdate(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserRegister(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserDeregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserDeregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserDeregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserDeregister(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser_Verify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserVerify(ctx, req.(*DatabaseUser_Verify))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_RedirectWhisperGroupAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).RedirectWhisperGroupAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/RedirectWhisperGroupAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).RedirectWhisperGroupAdd(ctx, req.(*RedirectWhisperGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_RedirectWhisperGroupRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).RedirectWhisperGroupRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/RedirectWhisperGroupRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).RedirectWhisperGroupRemove(ctx, req.(*RedirectWhisperGroup))
	}
	return interceptor(ctx, in, info, handler)
}

// V1_ServiceDesc is the grpc.ServiceDesc for V1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var V1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.V1",
	HandlerType: (*V1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InjectAudio",
			Handler:    _V1_InjectAudio_Handler,
		},
		{
			MethodName: "GetUptime",
			Handler:    _V1_GetUptime_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _V1_GetVersion_Handler,
		},
		{
			MethodName: "ServerCreate",
			Handler:    _V1_ServerCreate_Handler,
		},
		{
			MethodName: "ServerQuery",
			Handler:    _V1_ServerQuery_Handler,
		},
		{
			MethodName: "ServerGet",
			Handler:    _V1_ServerGet_Handler,
		},
		{
			MethodName: "ServerStart",
			Handler:    _V1_ServerStart_Handler,
		},
		{
			MethodName: "ServerStop",
			Handler:    _V1_ServerStop_Handler,
		},
		{
			MethodName: "ServerRemove",
			Handler:    _V1_ServerRemove_Handler,
		},
		{
			MethodName: "ContextActionAdd",
			Handler:    _V1_ContextActionAdd_Handler,
		},
		{
			MethodName: "ContextActionRemove",
			Handler:    _V1_ContextActionRemove_Handler,
		},
		{
			MethodName: "TextMessageSend",
			Handler:    _V1_TextMessageSend_Handler,
		},
		{
			MethodName: "LogQuery",
			Handler:    _V1_LogQuery_Handler,
		},
		{
			MethodName: "ConfigGet",
			Handler:    _V1_ConfigGet_Handler,
		},
		{
			MethodName: "ConfigGetField",
			Handler:    _V1_ConfigGetField_Handler,
		},
		{
			MethodName: "ConfigSetField",
			Handler:    _V1_ConfigSetField_Handler,
		},
		{
			MethodName: "ConfigGetDefault",
			Handler:    _V1_ConfigGetDefault_Handler,
		},
		{
			MethodName: "ChannelQuery",
			Handler:    _V1_ChannelQuery_Handler,
		},
		{
			MethodName: "ChannelGet",
			Handler:    _V1_ChannelGet_Handler,
		},
		{
			MethodName: "ChannelAdd",
			Handler:    _V1_ChannelAdd_Handler,
		},
		{
			MethodName: "ChannelRemove",
			Handler:    _V1_ChannelRemove_Handler,
		},
		{
			MethodName: "ChannelUpdate",
			Handler:    _V1_ChannelUpdate_Handler,
		},
		{
			MethodName: "UserQuery",
			Handler:    _V1_UserQuery_Handler,
		},
		{
			MethodName: "UserGet",
			Handler:    _V1_UserGet_Handler,
		},
		{
			MethodName: "UserUpdate",
			Handler:    _V1_UserUpdate_Handler,
		},
		{
			MethodName: "UserKick",
			Handler:    _V1_UserKick_Handler,
		},
		{
			MethodName: "TreeQuery",
			Handler:    _V1_TreeQuery_Handler,
		},
		{
			MethodName: "BansGet",
			Handler:    _V1_BansGet_Handler,
		},
		{
			MethodName: "BansSet",
			Handler:    _V1_BansSet_Handler,
		},
		{
			MethodName: "ACLGet",
			Handler:    _V1_ACLGet_Handler,
		},
		{
			MethodName: "ACLSet",
			Handler:    _V1_ACLSet_Handler,
		},
		{
			MethodName: "ACLGetEffectivePermissions",
			Handler:    _V1_ACLGetEffectivePermissions_Handler,
		},
		{
			MethodName: "ACLAddTemporaryGroup",
			Handler:    _V1_ACLAddTemporaryGroup_Handler,
		},
		{
			MethodName: "ACLRemoveTemporaryGroup",
			Handler:    _V1_ACLRemoveTemporaryGroup_Handler,
		},
		{
			MethodName: "DatabaseUserQuery",
			Handler:    _V1_DatabaseUserQuery_Handler,
		},
		{
			MethodName: "DatabaseUserGet",
			Handler:    _V1_DatabaseUserGet_Handler,
		},
		{
			MethodName: "DatabaseUserUpdate",
			Handler:    _V1_DatabaseUserUpdate_Handler,
		},
		{
			MethodName: "DatabaseUserRegister",
			Handler:    _V1_DatabaseUserRegister_Handler,
		},
		{
			MethodName: "DatabaseUserDeregister",
			Handler:    _V1_DatabaseUserDeregister_Handler,
		},
		{
			MethodName: "DatabaseUserVerify",
			Handler:    _V1_DatabaseUserVerify_Handler,
		},
		{
			MethodName: "RedirectWhisperGroupAdd",
			Handler:    _V1_RedirectWhisperGroupAdd_Handler,
		},
		{
			MethodName: "RedirectWhisperGroupRemove",
			Handler:    _V1_RedirectWhisperGroupRemove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _V1_Events_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ServerEvents",
			Handler:       _V1_ServerEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ContextActionEvents",
			Handler:       _V1_ContextActionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TextMessageFilter",
			Handler:       _V1_TextMessageFilter_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AuthenticatorStream",
			Handler:       _V1_AuthenticatorStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "grpc/MurmurRPC.proto",
}
